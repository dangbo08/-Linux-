# 内核工具与辅助函数

# 1.理解宏container_of

```c
#define container_of(ptr, type, member) ({                      \
        const typeof(((type *)0)->member) *__mptr = (ptr);      \
        (type *)((char *)__mptr - offsetof(type, member)); })
```

​	**通过结构体中某个成员的地址，反推出整个结构体的首地址。**

这个是与内核中独特的链表结构息息相关的。

假设我有一个

```c
struct student {
    int age;            // offset = 0
    char name[20];      // offset = 4
    struct list_head list; // offset = 24 (示例)
};
```

我只拿到的是 `&stu->list` 指针

```pgp
---- struct student ----
| age (4B)             |  offset 0
| name (20B)           |  offset 4
| list (16B)           |  offset 24   <-- 你手中只有这个指针
------------------------
```

container_of 做的事：

```c
struct student *p = (char *)list_ptr - offsetof(struct student, list);
p = list_ptr - 24
/*退回到结构体的首地址*/
```

​	**通过结构体中某个成员的地址，反推出整个结构体的首地址。**

​	所以我可以通过&stu->list的链表地址推出结构体的首地址，也就能够拿到age和name的值。

# 2.链表

​	来到了内核关键部分，不管是用户态的链表还是内核态的链表学起来都非常抽象。

内核链表是嵌入式链表：

```c
struct list_head {
    struct list_head *next, *prev;
};
```

使用链表的结构体必须内嵌一个list_head

```c
struct student {
    int age;
    struct list_head list;
};
```

链表节点是用户结构体的一部分

一个结构体可以同时加入多个链表。

**用户态链表的内存关系：**

用户态结构体：

```c
struct node {
    int data;
    struct node *next;
};
```

内存布局图：

```yaml
0x1000: [ node1 ]
          data = 10
          next = 0x3000  ----+
                            |
                            v
0x3000: [ node2 ]
          data = 20
          next = 0x5000  ----+
                            |
                            v
0x5000: [ node3 ]
          data = 30
          next = NULL
```

- 每个 node 是 malloc 出来的
- 所以地址完全不连续（0x1000 → 0x3000 → 0x5000）
- node 内部 `data` 和 `next` 是连续的（结构体内部的字段）

内核态链表的内存关系：

内核态结构体：

```c
struct student {
    int age;
    struct list_head list;  // list.next, list.prev
};
```

假设有 3 个 student：

```
student1地址：0x2000
student2地址：0x4000
student3地址：0x8000
```

它们在链表中的顺序（例如 stu1 → stu2 → stu3）：

```lua
stu1.list.next → stu2.list
stu2.list.next → stu3.list
stu3.list.next → stu1.list   （循环链表）
```

结构体内部内存布局（连续）：

stu1 从 0x2000 开始：

```lua
0x2000: [ student1 ]
         +---------+
         | age     | 4 bytes
         +---------+
         | list    | struct list_head
         |         |   list.next 8 bytes
         |         |   list.prev 8 bytes
         +---------+
```

stu1 的 list 内部结构：

```
0x2004: list.next = 0x4004  ----→ student2 的 list
0x200C: list.prev = 0x800C  ←---- student3 的 list
```

 完整链表关系图：

```lua
       +-------------------+
       |  struct student1  |
       +-------------------+
0x2004 list.next ------> 0x4004 (stu2.list)
0x200C list.prev <------ 0x800C (stu3.list)
       +-------------------+

       +-------------------+
       |  struct student2  |
       +-------------------+
0x4004 list.next ------> 0x8004 (stu3.list)
0x400C list.prev <------ 0x200C (stu1.list)
       +-------------------+

       +-------------------+
       |  struct student3  |
       +-------------------+
0x8004 list.next ------> 0x2004 (stu1.list)
0x800C list.prev <------ 0x400C (stu2.list)
       +-------------------+
```

# 3.代码演示

## 3.1.创建和初始化链表

​	有两种创建方式：

### 3.1.1.动态方法

​	动态方法由struct list_head组成，用INIT_LIST_HEAD宏初始化：

```c
struct list_head mylist;
INIT_LIST_HEAD(mylist);
/*以下是INIT_LIST_HEAD的展开*/
static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
	list->prev = list;
}
```

​	这里需要知道Linux内核链表是一个环形双向链表，链表头不是存数据，而是一个“哨兵节点（dummy node）”，标记链表的开始和结束。

​	空链表的结构如下：

```lua
mylist
  ↓
+--------+
|  HEAD  |
| next = &mylist  --┐
| prev = &mylist  --┘
+--------+
```

**链表为空时，链表头的 next 指向自己（表示：没有第一个节点）**

**链表为空时，链表头的 prev 指向自己（表示：没有最后一个节点）**

​	这样设计就不需要判断链表是否为空，我们之前使用链表都得判断一下链表是不是空链表，不是空才能去访问，不然容易造成访问野指针错误。

```c
/*遍历链表*/
list_for_each(pos, &mylist) {
    ...
}
/*内部实现*/
for (pos = mylist.next; pos != &mylist; pos = pos->next)
/*如果链表为空*/
mylist.next == &mylist
/*循环直接退出了*/
```

### 3.1.2.静态方法

​	静态分配通过LIST_HEAD宏完成。

```c
LIST_HEAD(mylist);

#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

#define LIST_HEAD_INIT(name) { &(name), &(name) }
```

​	静态和动态的区别就是一个需要自己开辟空间，一个不需要。

## 3.2.创建链表节点

​	需要创建新节点，只需要创建数据结构实例，初始化嵌入在其中的list_head字段。

```c
struct car *blackcar = kzalloc(sizeof(struct car),GFP_KERNEL);
//初始化内部的list
INIT_LIST_HEAD(&black->list);

```

## 3.3.添加链表节点

​	使用list_add添加链表：

```c
list_add(&redcar->list,&mylist);
list_add(&bulecar->list,&mylist);
/*原型*/
static inline void
list_add(struct list_head *entry, struct list_head *head)
{
    __list_add(entry, head, head->next);
}

static inline void
__list_add(struct list_head *entry,
                struct list_head *prev, struct list_head *next)
{
    next->prev = entry;
    entry->next = next;
    entry->prev = prev;
    prev->next = entry;
}
```

​	使用list_add_tail将新项插入到链表末尾

```c
list_add_tail(&redcar->list,&mylist);
list_add_tail(&bulecar->list,&mylist);
/*函数原型*/
static inline void
list_add_tail(struct list_head *entry, struct list_head *head)
{
    __list_add(entry, head->prev, head); //这里不一样
}
static inline void
__list_add(struct list_head *entry,
                struct list_head *prev, struct list_head *next)
{
    next->prev = entry;
    entry->next = next;
    entry->prev = prev;
    prev->next = entry;
}
```

## 3.4.删除链表节点

```c
list_del(&redcar->list);
static inline void
list_del(struct list_head *entry)
{
    __list_del(entry->prev, entry->next);
}
/*这里动态创建的节点还要手动释放*/
kfree(redcar);
```

## 3.5.遍历链表

​	使用宏list_for_each_entry(pos,head,member)进行遍历链表。

- head:链表的头节点
- member：数据结构，就是list
- pos：用于迭代。他是一个循环游标，就像for循环里面的int i 一样

```c
struct car *acar; //计数器
list_for_each_entry(acar,&mylist,list)
{
    printk("%d",acar.speed);
}
```

## 3.6.完整的代码

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/slab.h>       // kzalloc, kfree
#include <linux/list.h>       // list_head, list functions
#include <linux/string.h>     // strcpy

struct list_head carlist;


struct car {
    char carname[20];
    char carmodel[20];
    int max_speed;
    struct list_head list;
};



static int __init list_demo_init(void)
{
    INIT_LIST_HEAD(&carlist);
    struct car *bmwcar = kzalloc(sizeof(struct car),GFP_KERNEL);
    if (!bmwcar)
        return -ENOMEM;
    //初始化内部的list
    INIT_LIST_HEAD(&bmwcar->list);
    strcpy(bmwcar->carname , "bmw");
    strcpy(bmwcar->carmodel , "m4");
    bmwcar->max_speed = 360;
    list_add(&bmwcar->list,&carlist);
    struct car *acar; //计数器
    list_for_each_entry(acar, &carlist, list)
    {
        printk(KERN_INFO "carname = %s,carmodel = %s,max_speed = %d",acar->carname,acar->carmodel,acar->max_speed);
    }

    pr_info("hello_kernel_world\n");
    
    return 0;
}
static void __exit list_demo_exit(void)
{
    /* 在 exit 里面释放链表节点 */
    struct car *acar, *tmp;  
    list_for_each_entry_safe(acar, tmp, &carlist, list) {
        list_del(&acar->list);
        kfree(acar);
    }
    pr_info("goodbye kernel_world\n");
}
module_init(list_demo_init);
module_exit(list_demo_exit);
MODULE_AUTHOR("DB");
MODULE_LICENSE("GPL");
```

## 3.7.container_of的运用

```c
#include "car.h"
MODULE_LICENSE("GPL");

/* 引入 provider.c 导出的链表头 */
extern struct list_head carlist;

static int __init consumer_init(void)
{
    struct car *acar;

    printk("hello: start to read carlist...\n");

    list_for_each_entry(acar, &carlist, list) {
        printk("hello: carname=%s  carmodel=%s speed=%d\n", acar->carname,acar->carmodel, acar->max_speed);
    }

    return 0;
}

static void __exit consumer_exit(void)
{
    printk(KERN_INFO "consumer: exit\n");
}

module_init(consumer_init);
module_exit(consumer_exit);
/*这里用到了list_for_each_entry*/
/*原型：*/
#define list_for_each_entry(pos, head, member)				\
    for (pos = __container_of((head)->next, pos, member);		\
	 &pos->member != (head);					\
	 pos = __container_of(pos->member.next, pos, member))
/*就是使用__container_of*/
```

