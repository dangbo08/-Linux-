# 0.前言

​	这篇章节名字叫设备树的前瞻，之前学到这里被自己误导了，分层这一块学的不是很扎实，所以重新来了一遍，老想着使用stm32的方法直接去操作寄存器的GPIOx&GPIO_PIN ，但是一直没有实现，后面看韦东山的代码发现他是假操作，实际就是打印出来，看了真想像stm32那样操作需要自己创建一个库，并把地址那些文件全部编辑好，对应的地址映射，这样子做非常复杂，现在都是使用设备树文件，这样子做应该是Linux的内核的上古时代的操作了，或者裸机操作，直接放弃。

# 1.分层思想

​	分层思想也就是面向对象思想；如何来设计呢？

1. 驱动层
2. 硬件层
   1. 底板1
   2. 底板2
3. gpio：如何操作gpio

# 2.硬件层

​	我们在硬件层如何去确认操作的哪一个GPIO ?

​	GPIO分为什么？Group和Pin；属于哪一组GPIO，那一组GPIO的什么Pin脚。

```c
#define GROUP(x) (x>>16)
#define PIN(x)   (x&0xFFFF)
#define GROUP_PIN(g,p) ((g<<16) | (p))
```

`GROUP_PIN`就是我们需要使用的了，比如需要操作GPIO1_IO03;怎么操作？GROUP_PIN(1,3);

```c
uint32_t  a = GROUP_PIN(1,3);
/*这里就a就是合并为一个数，0x00010003*/
uint32_t  group = GROUP(a);
uint32_t  pin = PIN(a);
/*16进制4个为16位，(x>>16)就是0x0001覆盖了0x0003，(x&0xFFFF)就是0x00010003 & 0x0000FFFF,高位就归零了*/
```

​	面向对象肯定不是拉着一个宏定义到处走，采用驱动中的`file_operations`思维，该硬件开发板的gpio资源（resource）定义一个结构体：led_resource;

```c
struct led_resource {
	int pin; /*接收GROUP_PIN的值*/
};
/*让别人拿到led_resource*/
struct  led_resource get_led_resource(void);
```

​	以上就简单完成了硬件层的设计了，假的硬件层，主要介绍思路。

# 3.GPIO操作

​	上面的硬件层相当于我们拿到了，需要操作的GPIO，韦东山写的代码我理解的有点混乱；

```c
//printk("%s %s line %d, led %d\n", __FILE__, __FUNCTION__, __LINE__, which);
	if (!led_rsc)
	{
		led_rsc = get_led_resouce();
	}
	
```

​	在gpio操作这里使用到了get的方式，就是gpio操作主动去拉去资源（pull），这样gpio就必须知道有一个led_resouce，且知道资源从何而来，但是如果改成set，的方式，就是board主动去push，这样gpio就不知道资源从何而来，只要有开发板配置了这个资源gpio才会去操作。

​	这里就涉及到总线设备驱动模型了，这是下一讲的内容。

**底板代码：**

```c
/*资源库文件*/
#define GROUP(x) (x>>16)
#define PIN(x)   (x&0xFFFF)
#define GROUP_PIN(g,p) ((g<<16) | (p))

struct led_resource {
	int pin; /*接收GROUP_PIN的值*/
};

/*底板操作*/
static struct led_resource board_A_led = {
    .pin = GROUP_PIN(1,3),
};
static int __init board_A_init(void)
{
	set_led_resource(&board_A_led);
	return 0;
}
static int __exit board_A_exit(void)
{
    return 0;
}
module_init(board_A_init);
module_exit(board_A_exit);
```

**GPIO代码：**

```c
/*节选主要部分*/
static struct led_operations board_demo_led_opr = {
    .init = board_demo_led_init,
    .ctl  = board_demo_led_ctl,
};
struct led_resource *get_led_resource(void)
{
	return led_res;
}
EXPORT_SYMBOL(get_led_resource);

void set_led_resource(struct led_resource *res)
{
	led_res = res;
}
EXPORT_SYMBOL(set_led_resource);

void set_led_opr(struct led_operations *opr)
{
	led_opr = opr;
}
EXPORT_SYMBOL(set_led_opr);

struct led_operations *get_led_opr(void)
{
	return led_opr;
}
EXPORT_SYMBOL(get_led_opr);


/*
void set_led_resource(struct led_resource* led_resource)
{
    led_res = led_resource;
}
void set_led_opr(struct led_operations*led_opr){
    led_opr_board = led_opr;
}*/

static int __init gpio_init(void)
{
	set_led_opr(&board_demo_led_opr);
	return 0;
}

static void __exit gpio_exit(void)
{
}
module_init(gpio_init);
module_exit(gpio_exit);
MODULE_LICENSE("GPL");

/*EXPORT_SYMBOL：让“一个模块里的函数或变量，能被别的模块在运行时链接并使用”。*/
```

**字符驱动代码：**

```c
/*改变部分*/
led_opr_board = get_led_opr();
	if (!led_opr_board)
		return -ENODEV;
	return 0;
/*这一部分基本没做修改*/
```

# 4.现象

​	生成了三个模块：

```text
led_drv.ko 
chip_gpio_demo.ko
borad_A_led.ko
```

这三个模块就有insmod的顺序

```sh
root@ATK-IMX6U:/mnt# insmod led_drv.ko
led_drv: Unknown symbol get_led_opr (err 0)
insmod: ERROR: could not insert module led_drv.ko: Unknown symbol in module
root@ATK-IMX6U:/mnt#
# 这里先insmod led_drv就不知道get_led_opr

root@ATK-IMX6U:/mnt# insmod borad_A_led.ko
borad_A_led: Unknown symbol set_led_resource (err 0)
insmod: ERROR: could not insert module borad_A_led.ko: Unknown symbol in module
root@ATK-IMX6U:/mnt#
# 这里先insmod borad_A_led 就不知道set_led_resource
# 正确的顺序
root@ATK-IMX6U:/mnt# insmod chip_gpio_demo.ko
root@ATK-IMX6U:/mnt# insmod borad_A_led.ko
root@ATK-IMX6U:/mnt# insmod led_drv.ko
/home/db/vm_driver/led_04/led_drv.c led_init line 87
root@ATK-IMX6U:/mnt#
root@ATK-IMX6U:/mnt# ./led_test /dev/100ask_led0 on
/home/db/vm_driver/led_04/led_drv.c led_drv_open line 58
init gpio: group 1, pin 3
init pin of group 1 ...
/home/db/vm_driver/led_04/led_drv.c led_drv_write line 45
set led on: group 1, pin 3
set pin of group 1 ...
/home/db/vm_driver/led_04/led_drv.c led_drv_close line 67

```

