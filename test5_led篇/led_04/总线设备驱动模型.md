# 1.驱动进化之路：总线设备驱动模型

## 1.1.原始写法

​	原始驱动写法，记下物理地址使用ioremap进行地址映射，这样操作确实可以操作寄存器，并能跑程序，但是无法维护，如果更换SOC，将全部重写代码。

```c
#define GPIO_BASE 0x0209C000

static int __init led_init(void)
{
    gpio_base = ioremap(GPIO_BASE, 0x1000);
    register_chrdev(major, "led", &fops);
}
```

## 1.2.设备和驱动开始分离：第一次进化(platform 雏形)

​	**核心思想:硬件信息不该写在驱动里**

```
硬件资源
   ↓
platform_device  ← 描述硬件
   ↓
platform_driver  ← 驱动逻辑
```

**示例:**

**设备端：**

```c
static struct resource led_res[] = {
    {
        .start = 0x0209C000,
        .end   = 0x0209CFFF,
        .flags = IORESOURCE_MEM,
    }
};

static struct platform_device led_dev = {
    .name = "my_led",
    .resource = led_res,
    .num_resources = ARRAY_SIZE(led_res),
};
```

**驱动端（不关心具体地址）：**

```c
static int led_probe(struct platform_device *pdev)
{
    struct resource *res;

    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    base = ioremap(res->start, resource_size(res));
}
```

**进化点**：

-  驱动开始“通用化”
- 不再硬编码地址
-  驱动和设备解耦

## 1.3.关键跃迁：总线模型（Linux 驱动的骨架）

Linux 抽象出了一个**统一模型**：

```
        bus
       /   \
  device   driver
```

**三个核心结构体：**

| 角色 | 结构体                 |
| ---- | ---------------------- |
| 总线 | `struct bus_type`      |
| 设备 | `struct device`        |
| 驱动 | `struct device_driver` |

### 1.3.1.platform / i2c / spi / usb 本质是“总线”

| 类型     | 本质     |
| -------- | -------- |
| platform | 虚拟总线 |
| i2c      | I²C 总线 |
| spi      | SPI 总线 |
| usb      | USB 总线 |
| pci      | PCI 总线 |

# 2.驱动是如何自动匹配的？

​	当我们使用了总线后，驱动的复用性大大提高，复用性的提高意味着修改减少，不可能每增加一个设备就需要去驱动中增加匹配的机制吧；如果这样驱动代码中功能的语句就很少，全是如何匹配的代码。

​	而**匹配的关键机制：`match()`**

```c
int bus_match(struct device *dev, struct device_driver *drv);
```

  	这里就引入了platform ，这是什么呢？

​	**platform 是 Linux 已经帮你设计好的“一套通用设备管理框架”**

​	它类似于总线，但不完全是总线，

**总线的本质特征**：

1. **一主多从（或多设备）**
2. **能挂多个“同类型设备”**
3. **有统一的寻址 / 枚举 / 匹配规则**
4. **设备是“挂”在总线上的**

​	**比如说我需要写一个功能性的驱动，使用gpio操作led，但是它不属于I2C / SPI / USB这些总线，所以需要使用platform这种设备设备管理框架**

**platform 匹配规则：**

1. device.name == driver.name
2. Device Tree 的 `compatible`

```c
static struct platform_driver led_driver = {
    .driver = {
        .name = "my_led",
        .of_match_table = led_of_match,
    },
};
```

```dts
led@0209c000 {
    compatible = "my,my-led";
};
```

# 3.代码解析

​	通过代码来一步一步理解，比直接看理论来的快，且理解的扎实，这是我的一贯作风，我喜欢先代码在理论，所以一般会先看手册写代码，再去看课程，课程还是有必要看的，嵌入式很多是经验之谈，老程序员很多实用的技巧随口就说不会写在手册里面，所以课程还是有必要看到。

​	下面的代码属于没有引用设备树的代码，所以包含了**`platform_driver`**和**`platform_device`**两个部分。

**`platform_device`**：

```c
struct platform_device {
	const char	*name;
	int		id;
	bool		id_auto;
	struct device	dev;
	u32		num_resources;
	struct resource	*resource;
	const struct platform_device_id	*id_entry;
	char *driver_override; /* Driver name to force a match */
	/* MFD cell pointer */
	struct mfd_cell *mfd_cell;
	/* arch specific additions */
	struct pdev_archdata	archdata;
};
```

​	这部分主要是理解**`platform / resource / probe / match`** ，所以并不涉及到操作gpio。

​	代码还是从硬件开始，硬件重要的还是硬件资源resource;

```c
#ifndef _LED_RESOURCE_H
#define _LED_RESOURCE_H

/* GPIO3_0 */
/* bit[31:16] = group */
/* bit[15:0]  = which pin */
#define GROUP(x) (x>>16)
#define PIN(x)   (x&0xFFFF)
#define GROUP_PIN(g,p) ((g<<16) | (p))


#endif
```

与之前的内容比较少了：

```c
struct led_resource {
	int pin; /*接收GROUP_PIN的值*/
};
```

​	这里的resource结构体Linux系统给我们提供了。

**struct resource**:

```c
struct resource {
    resource_size_t start;
    resource_size_t end;
    const char *name;
    unsigned long flags;
    struct resource *parent, *sibling, *child;
};
```

| flags          | start / end 含义       |
| -------------- | ---------------------- |
| IORESOURCE_MEM | 寄存器物理地址范围     |
| IORESOURCE_IRQ | 中断号（start == end） |
| IORESOURCE_DMA | DMA 通道               |
| IORESOURCE_IO  | I/O 端口               |

```c
static struct resource resources[] = {
        { 
                .start = GROUP_PIN(3,1),
                .flags = IORESOURCE_IRQ,
                .name = "db_led_01",
        },
        {
                .start = GROUP_PIN(5,8),
                .flags = IORESOURCE_IRQ,
                .name = "db_led_02",
        },
};
```

然后就是**`platform_device`**结构体

```c
static struct platform_device board_A_led_dev = {
        .name = "db_led",
        .num_resources = ARRAY_SIZE(resources),
        .resource = resources,
        .dev = {
                .release = led_dev_release,
         },
};
```

**`platform_device`** 的职责是什么？

**向内核描述“这里有一个设备，它占用了哪些资源，叫什么名字”。**

只要完成这件事，**device ↔ driver 的匹配链路就能跑通**。

```c
/*.name = "db_led",*/
/*
platform_device.name  ==  platform_driver.driver.name
这是匹配机制，没有他，probe永远不会被调用
.name 是 platform_device 的“身份证”
*/
/*.num_resources = ARRAY_SIZE(resources),   //ARRAY_SIZE统计这个数组有多少个元素
        .resource = resources,*/
/*
设备 → 驱动 的“硬件信息通道”。
driver里面：
platform_get_resource(pdev, IORESOURCE_XXX, idx);就是从这里拿取的信息
*/
/*
.dev = {
                .release = led_dev_release,
         },
这是防止内核警告的
*/
```

| 成员                    | 是否必须 | 什么时候用   |
| ----------------------- | -------- | ------------ |
| `name`                  | ✔ 必须   | 用于匹配     |
| `id`                    | ❌ 可选   | 多实例设备   |
| `resource`              | ✔ 常用   | 硬件资源     |
| `num_resources`         | ✔ 常用   | 资源数量     |
| `dev.release`           | ✔ 必须   | 设备生命周期 |
| `dev.platform_data`     | ❌ 可选   | 非 DTS 传参  |
| `dev.of_node`           | ❌ DTS    | 设备树       |
| `dev.dma_mask`          | ❌ DMA    | DMA 设备     |
| `dev.coherent_dma_mask` | ❌ DMA    | DMA          |
| `id_auto`               | ❌ 高级   | 自动编号     |

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/miscdevice.h>
#include <linux/kernel.h>
#include <linux/major.h>
#include <linux/mutex.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/stat.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/tty.h>
#include <linux/kmod.h>
#include <linux/gfp.h>
#include <linux/platform_device.h>

#include "led_resource.h"

static struct resource resources[] = {
        { 
                .start = GROUP_PIN(3,1),
                .flags = IORESOURCE_IRQ,
                .name = "db_led_01",
        },
        {
                .start = GROUP_PIN(5,8),
                .flags = IORESOURCE_IRQ,
                .name = "db_led_02",
        },
};
/*
struct platform_device {
	const char	*name;
	int		id;
	bool		id_auto;
	struct device	dev;
	u32		num_resources;
	struct resource	*resource;

	const struct platform_device_id	*id_entry;
	char *driver_override; /* Driver name to force a match */

	/* MFD cell pointer */
	/*struct mfd_cell *mfd_cell;*/

	/* arch specific additions */
	/*struct pdev_archdata	archdata;
};*/
struct platform_device board_A_dev = {
    .name = "db_led",
    .num_resources = ARRAY_SIZE(resources),
    .resource = resources,
    .dev = {
        .release = led_dev_release,
    },
};
static int __init led_dev_init(void)
{
    int err;
    /* int platform_device_register(struct platform_device *pdev) */
    err = platform_device_register(&board_A_dev);
    return 0;
}

static void __exit led_dev_exit(void)
{
    platform_device_unregister(&board_A_dev);
}
  
module_init(led_dev_init);
module_exit(led_dev_exit);

MODULE_LICENSE("GPL");
```

**platform_driver_register**：

platform_driver_register 必须放在“知道硬件资源、负责匹配 platform_device 的那一层”

也就是我们操作gpio那一层。

```c
#include <linux/module.h>

#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/miscdevice.h>
#include <linux/kernel.h>
#include <linux/major.h>
#include <linux/mutex.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/stat.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/tty.h>
#include <linux/kmod.h>
#include <linux/gfp.h>
#include <linux/platform_device.h>


#include "led_opr.h"
#include "led_drv.h"
#include "led_resource.h"
static int g_ledpins[100];
static int g_ledcnt = 0;

static int board_demo_led_init (int which) /* 初始化LED, which-哪个LED */       
{   
    //printk("%s %s line %d, led %d\n", __FILE__, __FUNCTION__, __LINE__, which);
    
    printk("init gpio: group %d, pin %d\n", GROUP(g_ledpins[which]), PIN(g_ledpins[which] )) ;
    switch(GROUP(g_ledpins[which]))
    {
        case 0:
        {
            printk("init pin of group 0 ...\n");
            break;
        }
        case 1:
        { 
            printk("init pin of group 1 ...\n");
            break;
        }
        case 2:
        {
            printk("init pin of group 2 ...\n");
            break;
        }
        case 3:
        {
            printk("init pin of group 3 ...\n");
            break;
        }
    }
    
    return 0;
}

static int board_demo_led_ctl (int which, char status) /* 控制LED, which-哪个LED, status:1-亮,0-灭 */
{
    //printk("%s %s line %d, led %d, %s\n", __FILE__, __FUNCTION__, __LINE__, which, status ? "on" : "off");
    printk("set led %s: group %d, pin %d\n", status ? "on" : "off", GROUP(g_ledpins[which]), PIN(g_ledpins[which]));

    switch(GROUP(g_ledpins[which]))
    {
        case 0:
        {
            printk("set pin of group 0 ...\n");
            break;
        }
        case 1:
        {
            printk("set pin of group 1 ...\n");
            break;
        }
        case 2:
        {
            printk("set pin of group 2 ...\n");
            break;
        }
        case 3:
        {
            printk("set pin of group 3 ...\n");
            break;
        }
    }

    return 0;
}

static struct led_operations board_demo_led_opr = {
    .init = board_demo_led_init,
    .ctl  = board_demo_led_ctl,
};

struct led_operations *get_board_led_opr(void)
{
    return &board_demo_led_opr;
}

static int chip_demo_gpio_probe(struct platform_device *pdev)
{
    struct resource *res;
    int i = 0;
    while (1)
    {
        res = platform_get_resource(pdev,IORESOURCE_IRQ,i++);
        if(!res)
            break;
        g_ledpins[g_ledcnt] = res->start;
        led_class_create_device(g_ledcnt);
        g_ledcnt++;
    }
    return 0;
}

static int chip_demo_gpio_remove(struct platform_device *pdev)
{
    struct resource *res;
    int i = 0;

    while (1)
    {
        res = platform_get_resource(pdev, IORESOURCE_IRQ, i);
        if (!res)
            break;
        
        led_class_destroy_device(i);
        i++;
        g_ledcnt--;
    }
    return 0;
}

static struct platform_driver chip_demo_gpio_driver = {
    .probe      =   chip_demo_gpio_probe,
    .remove     =   chip_demo_gpio_remove,
    .driver     =   {
        .name   =   "db_led",
    },
};


static int __init gpio_init(void)
{
    int err;
    err = platform_driver_register(&chip_demo_gpio_driver);
    register_led_operations(&board_demo_led_opr);
    return 0;
}

static void __exit gpio_exit(void)
{
    platform_driver_unregister(&chip_demo_gpio_driver);
}


module_init(gpio_init);
module_exit(gpio_exit);
MODULE_LICENSE("GPL");
```

驱动设计顺序：

**问题来源于 user：点灯**

**led_drv 是“能力框架”**

**led_opr 是硬件适配接口**

**platform_\* 是最后才登场**

```
详细的解释就是，用户需求是能够点灯，led_drv点灯需求的能力框架，这第一步完成用户能够操作的接口：/dev/led，第二步就是设计如何操作led：led_init,led_ctl；也就是：
struct led_operations {
	int (*init) (int which); /* 初始化LED, which-哪个LED */       
	int (*ctl) (int which, char status); /* 控制LED, which-哪个LED, status:1-亮,0-灭 */
};
然后就是platform_xxxx，并根据platform_device里面的resources的成员数量创建次设备成员也就是 /dev/led01;/dev/led02
最后由gpio根据platform_driver拉取到的值，来控制对应的gpio
```

```c
/*伪代码*/
/*
1.注册主设备号：register_chrdev
2.根据主设备号注册时的需要封装：file_operations
3.创建/sys/xxx_class：class_create
4.由于device是由platform_device提供的所以device_create需要封装为框架层，并提供给外界使用（EXPORT_SYMBOL）
5.有创建就有led_class_destroy_device，这个也疯转为外部可用
5.如何控制led，设计led_operations
6.由于框架层不做任何操作led_operations的完成方法由外部提供，所以需要封装一个register_led_operations供外部使用
7.以上六步完成以后led_drv复用性大大提高，维护的时候基本不需要进行修改
8.实现led_operations，.init,.ctl;
9.platform_driver:name,probe,remove;name用做匹配，probe用作device_create的创建，remove就是移除了 然后platform_driver_register
10.platform_device：name，start，end，num_resources，resource，.dev:release,然后platform_device_register
*/
```

