# 1.中断的引入

​	在之前的小节中，我们提到了轮询，阻塞，poll和异步通知。这四个除了轮询没有使用到中断，其他三个或多或少都有一点，但是轮询非常浪费资源。嵌入式系统中就有很多这种情况，比如我们的CPU在正常运行，但是我们按下按键需要他去做其他事情这个就是中断，很简单的一个中断，做完了在回到主线程做该做的工作。

## 1.1.**中断的处理流程**

arm 对异常(中断)处理过程：

1. 初始化

   1. 设置中断源，让它可以产生中断
   2. 设置中断控制器(可以屏蔽某个中断，优先级)
   3. 设置 CPU 总开关(使能中断)

2. 执行其他程序：正常程序

3. 产生中断：比如按下按键--->中断控制器--->CPU

4. CPU 每执行完一条指令都会检查有无中断/异常产生

5. CPU 发现有中断/异常产生，开始处理。

   1. 对于不同的异常，跳去不同的地址执行程序。

   2. 这地址上，只是一条跳转指令，跳去执行某个函数(地址)，这个就是异常向

      量。③④⑤都是硬件做的。

6. 这些函数做什么事情？

   1. 保存现场(各种寄存器)
   2. 处理异常(中断):分辨中断源，再调用不同的处理函数
   3. 恢复现场

## 1.2.**异常向量表**

​	u-boot 或是 Linux 内核，都有类似如下的代码：

```
_start: b reset
ldr pc, _undefined_instruction
ldr pc, _software_interrupt
ldr pc, _prefetch_abort
ldr pc, _data_abort
ldr pc, _not_used
ldr pc, _irq //发生中断时，CPU 跳到这个地址执行该指令 **假设地址为 0x18**
ldr pc, _fiq
```

# 2.中断嵌套

| 维度         | 裸机（Bare Metal） | RTOS             | Linux            |
| ------------ | ------------------ | ---------------- | ---------------- |
| 设计目标     | **极致实时**       | 实时 + 可管理    | 通用、多任务     |
| 是否有进程   | ❌                  | ❌                | ✅                |
| 是否有线程   | ❌                  | ✅（任务）        | ✅                |
| 中断地位     | **核心控制流**     | **高优先级事件** | **事件触发器**   |
| ISR 里能干啥 | 几乎什么都能       | 尽量少           | 只能干最少       |
| 中断嵌套     | ✅ 自由嵌套         | ✅（可配置）      | ✅（受控）        |
| 栈模型       | 单栈 / ISR 栈      | ISR 栈 + 任务栈  | IRQ 栈 + 线程栈  |
| 中断后处理   | ISR 直接处理       | ISR + 任务       | hardirq + 下半部 |
| 适合场景     | MCU 控制           | 工控 / 实时      | 复杂系统         |

​	韦东山这里讲Linux不能中断嵌套有点绝对，Linux是支持硬件中断嵌套的。

## 2.1.Linux中断真正的执行模型

​	Linux讲中断拆成两半

**上半部（hardirq）**：

- 真正的中断上下文

- **运行时间必须极短**

- 通常：

  - ack 中断

  - 读取状态

  - 唤醒下半部

```c
irq_handler_t my_irq(int irq, void *dev)
{
    /* 只做最小事情 */
    tasklet_schedule(&xxx);
    return IRQ_HANDLED;
}
```

**下半部（softirq / tasklet / workqueue）**：

运行环境不同：

| 机制      | 运行在哪   | 能否睡眠 |
| --------- | ---------- | -------- |
| softirq   | 中断上下文 | ❌        |
| tasklet   | 中断上下文 | ❌        |
| workqueue | 内核线程   | ✅        |