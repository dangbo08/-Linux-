# 1.**Pinctrl** **子系统重要概念**

## 1.1.Pinctrl子系统是做什么的？

​	**pinctrl 子系统 = 管理 SoC 引脚“复用 + 电气属性 + 状态切换”的统一框架**

​	他解决的是这根物理引脚现在该干什么，用什么电气特性的问题。而GPIO子系统只关注一件事：这根引脚如果是gpio，现在是输入还是输出，拉高还是拉低。

## 1.2.为什么Pinctrl子系统必须存在？（裸机 vs Linux）

裸机做法：

```c
IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 = 0x5;   // 设为 GPIO
IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03 = 0x10B0;// 上拉、驱动能力
GPIO1_GDIR |= (1 << 3);
```

​	这个问题就是各个驱动之间各写各的，比如我现在需要这个引脚去做GPIO，那么复用为GPIO，另外一个驱动又需要做其他用途，又需要复用为其他，而且他的状态还不可切换。

**Linux 的解决方案：pinctrl**

把 **“寄存器级的引脚配置”** 从驱动里抽出来

由 **设备树 + pinctrl 子系统统一管理**

驱动只说一句：

```c
pinctrl_select_state(dev, state);
```

底层怎么配寄存器？驱动不关心

# 2.Pinctrl子系统的两个重要对象

1. **pin controller**

   - ```c
     /*
     在芯片手册里你找不到 pin controller，它是一个软件上的概念，你可以认为它对应 IOMUX──用来复用引脚，还可以配置引脚(比如上下拉电阻等)。
     注意，pin controller 和 GPIO Controller 不是一回事，前者控制的引脚可用于 GPIO 功能、I2C 功能；后者只是把引脚配置为输入、输出等简单的功能。
     即先用 pin controller 把引脚配置为 GPIO，再用 GPIO Controler 把引脚配置为输入或输出。
     */
     ```

2. **client device**

   - ```c
     /*
     “客户设备”，谁的客户？Pinctrl 系统的客户，那就是使用 Pinctrl 系统的设备，使用引脚的设备。
     它在设备树里会被定义为一个节点，在节点里声明要用哪些引脚。
     */
     ```

     

​	**pin controller**里面主要做：复用为什么功能，用到哪些引脚，配置成什么样。（每个SOC的**pin controller**的写法可能都不一样，但是主要做法就是这些）。

​	**client device**：这个就是用户的设备节点了。（1.这个设备哪些状态2.第x个状态对应的引脚在pinctrl-x里面定义）

**实例：**

```dts
client device：
/{
	myled{
        compatible = "db,db_led1";
        pinctrl-names = "default";
                pinctrl-0 = <&pinctrl_led>;
        
        led-gpios = <&gpio1 3 GPIO_ACTIVE_LOW>;
        status = "okay";
    };

};
//这个设备有一个状态，状态名称叫做default，在pinctrl里面对应pinctrl-0 = <&pinctrl_led>;
pin controller：
&iomuxc {
    imx6ul-evk {
        pinctrl_led: ledgrp {
            fsl,pins = <
                MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 0x10b0
            >;
        };
    };
};
```

**这个 MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 0x10b0的功能：**

| 内容                   | 作用          |
| ---------------------- | ------------- |
| `GPIO1_IO03`（PAD 名） | 对应物理引脚  |
| `__GPIO1_IO03`         | 选择 MUX 功能 |
| `0x10b0`               | PAD 电气属性  |

# 3.GPIO子系统的重要概念

​	要操作 GPIO 引脚，先把所用引脚配置为 GPIO 功能，这通过 Pinctrl 子系统来实现。然后就可以根据设置引脚方向(输入还是输出)、读值──获得电平状态，写值──输出高低电平。

​	当 BSP 工程师实现了 GPIO 子系统后，我们就可以操作设备树就可以完成对GPIO的控制。

​	在厂家提供的设备树中，“GPIO 组”就是一个 GPIO Controller：

```dts
gpio1: gpio@0209c000 {
				compatible = "fsl,imx6ul-gpio", "fsl,imx35-gpio";
				reg = <0x0209c000 0x4000>;
				interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
					     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
				gpio-controller;
				#gpio-cells = <2>;
				interrupt-controller;
				#interrupt-cells = <2>;
			};
//这个gpio1就是一个gpio组，#gpio-cells = <2>;有2个32 位的数描述他，就是说除了写组名还要两个成员用于描述：led-gpios = <&gpio1 3 GPIO_ACTIVE_LOW>;
```

# 4.在驱动代码中调用GPIO子系统

​	在设备树中指定了 GPIO 引脚，在驱动代码中如何使用？

​	也就是 GPIO 子系统的接口函数是什么？

​	GPIO 子系统有两套接口：基于描述符的(descriptor-based)、老的(legacy)。前者的函数都有前缀“gpiod_”，它使用 **gpio_desc** 结构体来表示一个引脚；后者的函数都有前缀“gpio_”，它使用一个整数来表示一个引脚。

​	驱动程序中要包含头文件：

```c
#include <linux/gpio/consumer.h> // descriptor-based
//或者
#include <linux/gpio.h> // legacy
```

```c
/*获得gpio*/
/*descriptor-based*/
gpiod_get;
gpiod_get_index;
gpiod_get_array;
denm_gpiod_get;
devm_gpiod_get_index;
devm_gpiod_get_array;
/*legacy*/
gpio_request;
gpio_request_array;
/*设置方向*/
/*descriptor-based*/
gpiod_direction_input;
gpiod_direction_output;
/*legacy*/
gpio_direction_input;
gpio_direction_output;
/*读值写值*/
/*descriptor-based*/
gpiod_get_value;
gpiod_set_value
/*legacy*/
gpio_get_value;
gpio_set_value;
/*释放 GPIO*/
/*descriptor-based*/
gpio_free;
gpiod_put;
gpiod_put_array;
devm_gpiod_put;
devm_gpiod_put_array;
/*legacy*/
gpio_free;
gpio_free_array;
```

​	有前缀“devm_”的含义是“设备资源管理”(Managed Device Resource)，这是一种自动释放资源的机制。它的思想是“资源是属于设备的，设备不存在时资源就可以自动释放”。

实例：

```dts
foo_device {
compatible = "acme,foo";
...
led-gpios = <&gpio 15 GPIO_ACTIVE_HIGH>, /* red */
 <&gpio 16 GPIO_ACTIVE_HIGH>, /* green */
 <&gpio 17 GPIO_ACTIVE_HIGH>; /* blue */
 power-gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
};
```

```c
struct gpio_desc *red, *green, *blue, *power;
red = gpiod_get_index(dev, "led", 0, GPIOD_OUT_HIGH);
green = gpiod_get_index(dev, "led", 1, GPIOD_OUT_HIGH);
blue = gpiod_get_index(dev, "led", 2, GPIOD_OUT_HIGH);
power = gpiod_get(dev, "power", GPIOD_OUT_HIGH);
//跟我之前写的一样
for (i = 0; i < priv->led_count; i++) {
        priv->leds[i].gpiod = devm_gpiod_get_index(dev,
                            "led", i, GPIOD_OUT_LOW);
        if (IS_ERR(priv->leds[i].gpiod))
            return PTR_ERR(priv->leds[i].gpiod);
        led_class_device_create(i);
    }
```

# 5.**sysfs** **中的访问方法**

​	每个GPIO组就是一个设备节点被挂载在gpio这个class下

```sh
root@ATK-IMX6U:/sys/class/gpio# ls
export  gpiochip0  gpiochip128  gpiochip32  gpiochip64  gpiochip96  unexport
```

​	进入某个 gpiochip 目录，查看文件 label 的内容，根据 label 的内容对比设备树，label 内容来自设备树

```sh
root@ATK-IMX6U:/sys/class/gpio/gpiochip0# cat label
209c000.gpio
#gpio1: gpio@0209c000
```

​	如果驱动没有占用引脚我也可以在这里操做引脚做输出还是输入，操做其电平的高低。

​	比如GPIO1_IO03这个引脚：

```sh
# GPIO1_IO03它来自GPIO1他的基准引脚就是gpiochip0
# 那么GPIO1_IO03就是0+3=3
export 3 > /sys/class/gpio/export
# 点灯需要做输出
echo out > /sys/class/gpio/gpio0/direction
# 这个时候就可以输入0/1去改变电平了
echo 1 > /sys/class/gpio/gpio0/value  # 熄灭
echo 0 > /sys/class/gpio/gpio0/value  # 点亮
```

