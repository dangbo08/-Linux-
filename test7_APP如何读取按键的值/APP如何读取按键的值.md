# 1.APP怎么读取按键值

​	在Linux系统中读取GPIO按键要考虑到效率，引入了很多种方法：查询方式（非阻塞），休眠-唤醒（阻塞方式），poll方式，异步通知方式。这四种方式并不仅仅用于GPIO按键，在所有的APP调用驱动过程中都是使用这四种方式学习。

1. 驱动的基本技能：中断、休眠、唤醒、poll 等机制。

   - 这些基本技能是驱动开发的基础，其他大型驱动复杂的地方是它的框架及设

     计思想，但是基本技术就这些。

2. APP 开发的基本技能：阻塞 、非阻塞、休眠、poll、异步通知。

​	韦东山这里使用孩子睡觉来举例

**妈妈怎么知道卧室里小孩醒了？**

1. 时不时进房间看一下：查询方式	
   1. 简单，但是累
2. 进去房间陪小孩一起睡觉，小孩醒了会吵醒她：休眠-唤醒
   1. 不累，但是妈妈干不了活了
3. 妈妈要干很多活，但是可以陪小孩睡一会，定个闹钟：poll 方式
   1. 要浪费点时间，但是可以继续干活。
   2. 妈妈要么是被小孩吵醒，要么是被闹钟吵醒。
4. 妈妈在客厅干活，小孩醒了他会自己走出房门告诉妈妈：异步通知
   1. 妈妈、小孩互不耽误。

**APP 去读取按键和举例的场景很相似，也有 4 种方法：**

1. 查询方式
2. 休眠-唤醒方式
3. poll 方式
4. 异步通知方式

​	第 2、3、4 种方法，都涉及中断服务程序。**中断**，就像小孩醒了会哭闹一样，中断不经意间到来，它会做某些事情：唤醒 APP、向 APP 发信号。

​	**所以，在按键驱动程序中，中断是核心。**

​	实际上，**中断**无论是在单片机还是在 Linux 中都很**重要**。在 Linux 中，**中断的知识还涉及进程、线程等**。

| 方式              | APP 行为            | 内核关键机制            | 是否需要中断 |
| ----------------- | ------------------- | ----------------------- | ------------ |
| 查询（非阻塞）    | `read(O_NONBLOCK)`  | 直接读状态              | ❌ 可不用     |
| 休眠-唤醒（阻塞） | `read()` 阻塞       | wait_queue              | ✅            |
| poll              | `poll/select/epoll` | wait_queue + poll_table | ✅            |
| 异步通知          | `SIGIO`             | fasync                  | ✅            |

# 2.代码解析

​	韦东山这里使用的是轮询的方式来访问按键的值，且他没有讲述pinctrl子系统，所以又无法使用设备树，于是还是采用了ioremap地址映射的方式，相当于stm32中的库文件只不过这个库文件是自己封装的，非常不便利，由于之前我采用了gpio子系统和pinctrl子系统来控制led，所以这一讲依然使用这种方式，韦东山那种方式在控制led那一讲我已经使用过了，所以不在重复书写。